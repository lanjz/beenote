<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
  var test = "```\nvar arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];\n\nvar newArr = [...new Set(arr.flat(Infinity))].sort(\n    (a, b) => {\n        return a-b\n    })\n\nconsole.log(newArr) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n```\n\n# [Array.prototype.flat()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)\n\n`flat()`方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中元素合并为一个新数组返回\n\n用法：`var newArray = arr.flat(depth)`\n\n参数：\n\n  - `depth `可选：指定要提取嵌套数组的结构深度，默认值为 1,使用 Infinity 作为深度，展开任意深度的嵌套数组\n\n## 示例\n\n```\nvar arr1 = [1, 2, [3, 4]];\narr1.flat(); \n// [1, 2, 3, 4]\n\nvar arr2 = [1, 2, [3, 4, [5, 6]]];\narr2.flat();\n// [1, 2, 3, 4, [5, 6]]\n\nvar arr3 = [1, 2, [3, 4, [5, 6]]];\narr3.flat(2);\n// [1, 2, 3, 4, 5, 6]\n\n//使用 Infinity 作为深度，展开任意深度的嵌套数组\narr3.flat(Infinity); \n// [1, 2, 3, 4, 5, 6]\n```\n\n## `flat()`将移除数组中的空项\n\n```\nvar arr4 = [1, 2, , 4, 5];\narr4.flat();\n// [1, 2, 4, 5]\n```\n\n# 使用`concat`、`reduce`方法代替`flat`方法\n\n```javascript\nfunction flattenDeep(arr) {\n    return arr.reduce((a, b) => a.concat(Array.isArray(b) ? flattenDeep(b) : b), [])\n}\nconsole.log(flattenDeep(arr))\n```\n\n[代替方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)\n\n## `Array.concat`\n\n- 语法: `arrayObject.concat(arrayX,arrayX,......,arrayX)`\n\n- 参数：\n  \n  @params {数组 || 数值} arrayX ：必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。\n\n## `Array.reduce`\n\n- 语法: `array.reduce(function(total, currentValue, currentIndex, arr), initialValue)`\n\n- 参数：\n  \n  @params {any} total：必需。初始值, 或者计算结束后的返回值。\n  \n  @params {any} currentValue：必需。当前元素\n  \n  @params {any} currentIndex：可选。当前元素的索引\n  \n  @params {any} arr：可选。当前元素所属的数组对象。\n  \n  @params {any} initialValue：可选。传递给函数的初始值\n  \n  \n"


  function filterTxt(txt) {
    if(!txt) return txt
    const filterReg = /(#|##)\s(.+)\n/g
    const filterLink = /\[(.+)\]\(.+\)/g
    let getText = txt.replace(filterReg, function () {
      return arguments[2]
    })
    getText = getText.replace(filterLink, function () {
      if(arguments[1]) {
        return arguments[1]
      }
    })
    getText = getText.replace('`', '')
    return getText
  }
  function createCatalogue(title, test) {
    let parentTitle = title
    const obj = {
      [title]: []
    }
    const reg = /(#|##)\s(.*)\n/g
    const find = test.match(reg)
    console.log(find)
    if(find && find.length) {
      find.forEach(item => {
        const t = filterTxt(item)
        if(item[0] === '#' && item[1] != '#') {
          obj[title].push({
            name: t,
            parent: title
          })
          parentTitle = t
        } else if(item[0] === '#' && item[1] == '#') {
          const curParent = parentTitle || title
          if(!obj[curParent]) {
            obj[curParent] = []
          }
          obj[curParent].push(
            {
              name: t,
              parent: curParent
            }
          )
        }
      })
    }
    return obj
  }
  console.log(createCatalogue('经一', test))
</script>
</body>
</html>
